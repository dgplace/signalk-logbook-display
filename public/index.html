<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Logbook</title>
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  /* adopt Signal K theme variables with fallbacks */
  body, html {
    height: 100%;
    margin: 0;
    /* subtle shaded background */
    background: var(--background-page-color, #f6f7fb);
    color: var(--text-color, #000000);
    font-family: var(--font-family, sans-serif);
  }
  .container {
    width: 95%;
    margin: 0 auto;
    height: 100vh;            /* fill full viewport */
    display: grid;
    grid-template-rows: 25% 75%; /* 25% header/table, 75% map/panel */
    gap: 12px;
  }
  .top-section {
    display: flex;
    flex-direction: column;
    min-height: 0; /* allow inner scroll */
  }
  .header-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .table-wrapper {
    flex: 1 1 auto;
    min-height: 0;           /* important for flex children to allow overflow */
    overflow: auto;          /* scrollable table body */
    border: 1px solid var(--border-color, #e2e8f0);
    border-radius: 8px;
    background: var(--background-panel-color, #ffffff);
    box-shadow: 0 1px 2px rgba(0,0,0,0.06);
  }
  .map-row {
    display: flex;
    gap: 12px;
    align-items: stretch;
    min-height: 0; /* allow map to size correctly */
  }
  #map {
    flex: 1 1 87.5%;
    height: 100%;
    min-height: 200px;
  }
  /* style the regeneration button to match SK buttons */
  button#regenBtn {
    background-color: var(--button-primary-bg-color, #2563eb);
    color: var(--button-primary-text-color, #ffffff);
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
  }
  button#regenBtn:hover {
    background-color: var(--button-primary-bg-hover-color, #1e40af);
  }
  /* give the table Signal K‑style borders and zebra stripes */
  table {
    width: 100%;
    border-collapse: collapse;
    background: var(--background-table-color, #ffffff);
  }
  th, td {
    padding: 8px;
    border-bottom: 1px solid var(--border-color, #e5e7eb);
  }
  th {
    background-color: var(--table-header-bg-color, #f3f4f6);
    color: var(--table-header-text-color, #000000);
    position: sticky;  /* sticky header for scroll */
    top: 0;
    z-index: 1;
  }
  tbody tr:nth-child(odd) {
    background-color: var(--table-row-bg-alt-color, #fafafa);
  }
  tbody tr:hover {
    background-color: var(--table-row-hover-bg-color, #e5e7eb);
  }
  tr.selected-row {
    background-color: #dbeafe; /* highlight selected voyage */
  }
  .details-panel {
    flex: 0 0 12.5%;
    min-width: 180px;
    max-width: 420px;
    padding: 10px;
    border: 1px solid var(--border-color, #e2e8f0);
    border-radius: 8px;
    background-color: var(--background-input-color, #ffffff);
    height: 100%;
    overflow: auto;
    box-shadow: 0 1px 2px rgba(0,0,0,0.06);
  }
  .expander-btn {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 0.9em;
    margin-right: 6px;
  }
  .day-row {
    background-color: var(--table-row-bg-alt-color, rgba(0,0,0,0.03));
  }
  .day-row.hidden { display: none; }
  .idx-cell { white-space: nowrap; }

  /* Small square marker for selected point */
  .square-marker {
    width: 10px;
    height: 10px;
    background: var(--accent-color, #ef4444);
    border: 2px solid #ffffff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
  }
  /* Tiny square markers for highlighted track points */
  .tiny-square-marker {
    width: 6px;
    height: 6px;
    background: var(--accent-muted, #1d4ed8);
    opacity: 0.9;
    border: 1px solid #ffffff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.2);
  }
  .wind-speed-label {
    padding: 2px 4px;
    font-size: 11px;
    background: rgba(0,0,0,0.6);
    color: #fff;
    border-radius: 3px;
    white-space: nowrap;
  }
  .wind-arrow { position: relative; transform-origin: 50% 50%; pointer-events: none; }
</style>
</head>
<body>
<div class="container">
  <div class="top-section">
    <div class="header-bar">
      <h2 style="margin: 8px 0;">Logbook</h2>
      <button id="regenBtn">Regenerate voyages</button>
    </div>
    <div class="table-wrapper">
      <table id="voyTable">
        <thead><tr><th>#</th><th>Start</th><th>End</th><th>NM</th><th>Max Speed</th><th>Avg Speed</th><th>Max Wind</th><th>Avg Wind</th><th>Avg Wind Dir</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <div class="map-row">
    <div id="map"></div>
    <div id="pointDetails" class="details-panel" aria-live="polite"></div>
  </div>
</div>

<script>
/**
 * degToCompass
 * Purpose: Convert degrees [0,360) to 8-point compass string.
 * Input: deg: number
 * Output: 'N','NE','E','SE','S','SW','W','NW'
 */
function degToCompass(deg) {
  const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  return dirs[Math.round(deg / 45) % 8];
}
</script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
let map, polylines = [], maxMarker;
let activePolylines = [];        // currently highlighted red polylines
let activeLineClickers = [];     // stored click handlers for active polylines
let selectedPointMarker = null;  // marker for selected point (boat triangle)
let squareIcon = L.divIcon({ className: 'square-marker', iconSize: [10,10] });
let tinySquareIcon = L.divIcon({ className: 'tiny-square-marker', iconSize: [6,6] });
let activePointMarkersGroup = null; // group of tiny markers for highlighted track
let selectedWindGroup = null;       // group for wind arrow + label

/**
 * getVoyagePoints
 * Purpose: Normalize voyage data to a list of {lat, lon, entry?} points.
 * Input: v (voyage object)
 * Output: Array of point-like objects with lat/lon
 */
function getVoyagePoints(v) {
  if (Array.isArray(v.points) && v.points.length) return v.points;
  if (Array.isArray(v.entries) && v.entries.length) return v.entries;
  if (Array.isArray(v.coords) && v.coords.length) return v.coords.map(([lon, lat]) => ({ lon, lat }));
  return [];
}

/**
 * drawMaxSpeedMarkerFromCoord
 * Purpose: Show orange circle at max speed coordinate with popup.
 * Input: coord: [lon,lat] or null, speed: number
 * Output: Places/updates global maxMarker on map
 */
function drawMaxSpeedMarkerFromCoord(coord, speed) {
  if (maxMarker) { map.removeLayer(maxMarker); maxMarker = null; }
  if (coord && coord.length === 2) {
    const [lon, lat] = coord;
    maxMarker = L.circleMarker([lat, lon], { color: 'orange', radius: 6 }).addTo(map);
    maxMarker.bindPopup(`Max SoG: ${Number(speed).toFixed(1)} kn`).openPopup();
  }
}

/**
 * setSelectedTableRow
 * Purpose: Visually highlight the selected voyage/day in the table.
 * Input: row: HTMLTableRowElement
 * Output: Applies CSS class to row and removes from others
 */
function setSelectedTableRow(row) {
  document.querySelectorAll('#voyTable tr.selected-row').forEach(r => r.classList.remove('selected-row'));
  if (row) row.classList.add('selected-row');
}

/**
 * clearActivePointMarkers
 * Purpose: Remove tiny point markers for the active track.
 * Input: none
 * Output: Clears layer group from map
 */
function clearActivePointMarkers() {
  if (activePointMarkersGroup) { map.removeLayer(activePointMarkersGroup); activePointMarkersGroup = null; }
}

/**
 * clearSelectedWindGraphics
 * Purpose: Remove wind arrow overlay tied to selected point.
 * Input: none
 * Output: Clears layer from map
 */
function clearSelectedWindGraphics() {
  if (selectedWindGroup) { map.removeLayer(selectedWindGroup); selectedWindGroup = null; }
}

/**
 * nearestHour
 * Purpose: Round a Date to nearest hour and format to 12h am/pm label.
 * Input: dateStr: string|number|Date
 * Output: { d: Date, label: string } or '—'
 */
function nearestHour(dateStr) {
  if (!dateStr) return '—';
  const d = new Date(dateStr);
  if (Number.isNaN(d)) return '—';
  d.setMinutes(d.getMinutes() + 30);
  d.setMinutes(0,0,0);
  let h = d.getHours();
  const ampm = h >= 12 ? 'pm' : 'am';
  h = h % 12; if (h === 0) h = 12;
  return { d, label: `${h}${ampm}` };
}

/**
 * dateHourLabel
 * Purpose: Return compact date plus nearest hour (e.g., "Sep 8, 2pm").
 * Input: dateStr
 * Output: string
 */
function dateHourLabel(dateStr) {
  const res = nearestHour(dateStr);
  if (res === '—') return res;
  const { d, label } = res;
  const dateTxt = d.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
  return `${dateTxt} ${label}`;
}

function arrowSizeFromSpeed(kn) {
  const small = 60;   // ~= 5 kn
  const mid   = 180;  // ~= 25 kn
  const large = 240;  // > 25 kn (emphasized)
  if (!(typeof kn === 'number') || Number.isNaN(kn)) return small;
  if (kn <= 5) return small;
  if (kn >= 25) return large;
  const t = (kn - 5) / 20; // 0..1 across 5..25
  return Math.round(small + t * (mid - small));
}

/**
 * makeBoatIcon
 * Purpose: Create a long-triangle boat icon rotated to bearing.
 * Input: bearingDeg: number (0..360)
 * Output: Leaflet DivIcon
 */
function makeBoatIcon(bearingDeg) {
  const w = 18, h = 36; // long triangle
  const html = `
    <div class="boat-icon" style="width:${w}px;height:${h}px;transform: rotate(${bearingDeg.toFixed(1)}deg);">
      <svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
        <polygon points="${w/2},2 2,${h-2} ${w-2},${h-2}" fill="var(--accent-color, #ef4444)" stroke="#ffffff" stroke-width="1.5" />
      </svg>
    </div>`;
  return L.divIcon({ className: '', html, iconSize: [w, h], iconAnchor: [w/2, h/2] });
}

/**
 * bearingBetween
 * Purpose: Initial bearing from A(lat1,lon1) to B(lat2,lon2).
 * Input: numbers in degrees
 * Output: bearing degrees (0..360), 0=N
 */
function bearingBetween(lat1, lon1, lat2, lon2) {
  const toRad = (d) => d * Math.PI / 180;
  const toDeg = (r) => r * 180 / Math.PI;
  const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const Δλ = toRad(lon2 - lon1);
  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
  let θ = Math.atan2(y, x);
  θ = (toDeg(θ) + 360) % 360; // 0..360, 0=N
  return θ;
}

/**
 * courseFromNeighbors
 * Purpose: Estimate course at selected point using neighbors.
 * Input: prev, sel, next points (may be undefined)
 * Output: bearing degrees
 */
function courseFromNeighbors(prev, sel, next) {
  if (prev && typeof prev.lat === 'number' && typeof prev.lon === 'number' &&
      next && typeof next.lat === 'number' && typeof next.lon === 'number') {
    return bearingBetween(prev.lat, prev.lon, next.lat, next.lon);
  }
  if (prev && typeof prev.lat === 'number' && typeof prev.lon === 'number') {
    return bearingBetween(prev.lat, prev.lon, sel.lat, sel.lon);
  }
  if (next && typeof next.lat === 'number' && typeof next.lon === 'number') {
    return bearingBetween(sel.lat, sel.lon, next.lat, next.lon);
  }
  return 0;
}

/**
 * extractHeadingDegrees
 * Purpose: Return heading in degrees from entry.heading (0=N), if present.
 * Input: entry: object with numeric heading in degrees
 * Output: number in [0,360) or undefined
 */
function extractHeadingDegrees(entry) {
  if (!entry || typeof entry !== 'object') return undefined;
  const v = entry.heading;
  if (typeof v !== 'number' || Number.isNaN(v)) return undefined;
  return ((v % 360) + 360) % 360;
}

function updateSelectedPoint(sel, neighbors = {}) {
  if (!sel || typeof sel.lat !== 'number' || typeof sel.lon !== 'number') return;
  const lat = sel.lat, lon = sel.lon;
  const entry = sel.entry || sel;
  // Prefer stored heading; fall back to course estimated from neighbors
  const storedHeading = extractHeadingDegrees(entry);
  const bearing = (typeof storedHeading === 'number')
    ? storedHeading
    : courseFromNeighbors(neighbors.prev, sel, neighbors.next);
  if (!selectedPointMarker) {
    selectedPointMarker = L.marker([lat, lon], { icon: makeBoatIcon(bearing), zIndexOffset: 1000 }).addTo(map);
  } else {
    selectedPointMarker.setLatLng([lat, lon]);
    selectedPointMarker.setIcon(makeBoatIcon(bearing));
  }
  // Draw wind arrow for this point (constant pixel size, bearing = windDir + 180)
  clearSelectedWindGraphics();
  const windSpd = entry?.wind?.speed;
  let windDir = entry?.wind?.direction;
  if (typeof windSpd === 'number' && typeof windDir === 'number') {
    windDir = (windDir + 180) % 360;
    const angle = windDir.toFixed(1);
    const size = arrowSizeFromSpeed(windSpd);
    const c = size / 2;                 // center
    const tipY = size * 0.10;           // tip of arrow
    const headBaseY = tipY + size * 0.125; // base of triangle head
    const halfHead = size * 0.075;      // half width of head
    const shaftTopY = tipY + size * 0.075; // shaft end just before head
    const strokeW = Math.max(2, Math.round(size / 40));
    const html = `
      <div class="wind-arrow" style="width:${size}px;height:${size}px;transform: rotate(${angle}deg);">
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
          <line x1="${c}" y1="${c}" x2="${c}" y2="${shaftTopY}" stroke="#111827" stroke-width="${strokeW}" />
          <polygon points="${c},${tipY} ${c - halfHead},${headBaseY} ${c + halfHead},${headBaseY}" fill="#111827" />
        </svg>
        <div class="wind-speed-label" style="position:absolute;top:0;left:50%;transform:translate(-50%,-4px);">${windSpd.toFixed(1)} kn</div>
      </div>`;
    selectedWindGroup = L.marker([lat, lon], {
      icon: L.divIcon({ className: '', html, iconSize: [size,size], iconAnchor: [c,c] }),
      interactive: false
    }).addTo(map);
  }
  renderPointDetails(sel);
}

/**
 * load
 * Purpose: Initialize/refresh map, build table, and wire interactions from voyages.json.
 * Input: none
 * Output: fully rendered UI
 */
async function load() {
  // fetch the data
  const res  = await fetch('voyages.json');
  const data = await res.json();

  // if map already exists (after regeneration), remove it
  if (map) {
    map.off();       // remove all listeners
    map.remove();    // safely destroy the Leaflet map instance
  }
  polylines = [];
  maxMarker = null;

  map = L.map('map').setView([0, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              { maxZoom: 19 }).addTo(map);

  const tbody = document.querySelector('#voyTable tbody');
  tbody.innerHTML = ''; // clear existing rows

  data.voyages.forEach((v, i) => {
    // create table row
    const avgWindDir = (v.avgWindHeading !== undefined && v.avgWindHeading !== null) ? degToCompass(v.avgWindHeading) : '';
    const row = tbody.insertRow();

    // Compute day segments if we have timestamped points
    const hasPoints = Array.isArray(v.points) && v.points.length && v.points[0].entry?.datetime;
    const segments = computeDaySegments(v);
    v._segments = segments; // store for later use

    const isMultiDay = segments.length > 1;
    const expander = isMultiDay ? `<button class="expander-btn" aria-label="Toggle days">▸</button>` : '';

    row.innerHTML =
      `<td class="idx-cell">${expander}${i+1}</td><td>${dateHourLabel(v.startTime)}</td>
       <td>${dateHourLabel(v.endTime)}</td>
       <td>${v.nm.toFixed(1)}</td>
       <td>${v.maxSpeed.toFixed(1)}</td>
       <td>${v.avgSpeed.toFixed(1)}</td>
       <td>${v.maxWind.toFixed(1)}</td>
       <td>${v.avgWindSpeed.toFixed(1)}</td>
       <td>${avgWindDir}</td>`;

    // draw the polyline(s) for this voyage and store them
    let voyageBounds = null;
    if (segments.length > 0) {
      segments.forEach(seg => {
        const latLngs = seg.points.map(p => [p.lat, p.lon]);
        const pl = L.polyline(latLngs, { color: 'blue', weight: 2 }).addTo(map);
        seg.polyline = pl;
        polylines.push(pl);
        const b = pl.getBounds();
        voyageBounds = voyageBounds ? voyageBounds.extend(b) : b;
        // clicking a blue path selects voyage and the table row
        const voySelect = (ev) => { L.DomEvent.stopPropagation(ev); row.click(); };
        pl.on('click', voySelect);
        pl._voySelect = voySelect;
      });
    } else {
      // fallback: draw entire voyage as a single line from coords
      const latLngs = v.coords.map(([lon, lat]) => [lat, lon]);
      const line = L.polyline(latLngs, { color: 'blue', weight: 2 }).addTo(map);
      polylines.push(line);
      v._fallbackPolyline = line;
      voyageBounds = line.getBounds();
      const voySelect = (ev) => { L.DomEvent.stopPropagation(ev); row.click(); };
      line.on('click', voySelect);
      line._voySelect = voySelect;
    }
    if (i === 0 && voyageBounds) map.fitBounds(voyageBounds);

    // click handler to highlight this line
    row.addEventListener('click', () => {
      setSelectedTableRow(row);
      // reset all polylines to default style
      polylines.forEach(pl => { pl.setStyle({ color: 'blue', weight: 2 }); if (pl._voySelect) { try { pl.off('click', pl._voySelect); } catch(_) {} pl.on('click', pl._voySelect); } });
      // remove previous click handlers
      detachActiveClickers();
      // remove tiny point markers and wind arrow
      clearActivePointMarkers();
      clearSelectedWindGraphics();

      // highlight selected voyage (all segments or fallback line)
      activePolylines = [];
      if (v._segments && v._segments.length > 0) {
        v._segments.forEach(seg => {
          seg.polyline.setStyle({ color: 'red', weight: 4 });
          activePolylines.push(seg.polyline);
        });
        // fit map bounds to selected voyage
        if (v._segments[0].polyline) {
          let b = v._segments[0].polyline.getBounds();
          for (let k = 1; k < v._segments.length; k++) {
            b = b.extend(v._segments[k].polyline.getBounds());
          }
          map.fitBounds(b);
        }
      } else if (v._fallbackPolyline) {
        v._fallbackPolyline.setStyle({ color: 'red', weight: 4 });
        activePolylines = [v._fallbackPolyline];
        map.fitBounds(v._fallbackPolyline.getBounds());
      }
      // update max speed marker
      drawMaxSpeedMarkerFromCoord(v.maxSpeedCoord, v.maxSpeed);

      // clear previous point selection and handler
      if (selectedPointMarker) {
        map.removeLayer(selectedPointMarker);
        selectedPointMarker = null;
      }
      detachActiveClickers();

      // attach click handler to red path to select nearest point
      const voyagePoints = getVoyagePoints(v);
      activePolylines.forEach(pl => {
        // disable voyage-select on active red paths; enable point selection
        if (pl._voySelect) { try { pl.off('click', pl._voySelect); } catch(_) {} }
        const onLineClick = (e) => onPolylineClick(e, voyagePoints);
        pl.on('click', onLineClick);
        activeLineClickers.push({ pl, onLineClick });
      });
      // add tiny markers for all points on highlighted track
      if (Array.isArray(voyagePoints) && voyagePoints.length) {
      activePointMarkersGroup = L.layerGroup();
      voyagePoints.forEach((p, idx) => {
        if (typeof p.lat === 'number' && typeof p.lon === 'number') {
          const m = L.marker([p.lat, p.lon], { icon: tinySquareIcon });
          m.on('click', (ev) => {
            L.DomEvent.stopPropagation(ev);
            updateSelectedPoint(p, { prev: voyagePoints[idx-1], next: voyagePoints[idx+1] });
          });
          m.addTo(activePointMarkersGroup);
        }
      });
        activePointMarkersGroup.addTo(map);
      }
      // initial details hint
      setDetailsHint('Click on the red path to inspect a point.');
    });

    // if multi-day, add collapsible day rows
    if (isMultiDay) {
      const dayRows = [];
      // use sectionRowIndex which is index within tbody, not global rowIndex
      let insertIndex = row.sectionRowIndex + 1;
      segments.forEach((seg, idx) => {
        const dr = tbody.insertRow(insertIndex);
        dr.classList.add('day-row', 'hidden');
        const avgWindDirDay = (seg.avgWindHeading !== undefined && seg.avgWindHeading !== null) ? degToCompass(seg.avgWindHeading) : '';
        dr.innerHTML = `
          <td class="idx-cell">↳ ${i+1}.${idx+1}</td>
          <td>${dateHourLabel(seg.startTime)}</td>
          <td>${dateHourLabel(seg.endTime)}</td>
          <td>${seg.nm.toFixed(1)}</td>
          <td>${seg.maxSpeed.toFixed(1)}</td>
          <td>${seg.avgSpeed.toFixed(1)}</td>
          <td>${seg.maxWind.toFixed(1)}</td>
          <td>${seg.avgWindSpeed.toFixed(1)}</td>
          <td>${avgWindDirDay}</td>
        `;

        // click handler for day row
        dr.addEventListener('click', () => {
          // reset to default
          polylines.forEach(pl => pl.setStyle({ color: 'blue', weight: 2 }));
          detachActiveClickers();
          clearActivePointMarkers();
          clearSelectedWindGraphics();
          activePolylines = [];
          // highlight only this day
          if (seg.polyline) {
            seg.polyline.setStyle({ color: 'red', weight: 4 });
            activePolylines = [seg.polyline];
            map.fitBounds(seg.polyline.getBounds());
          }
          // update max speed marker for this day
          drawMaxSpeedMarkerFromCoord(seg.maxSpeedCoord, seg.maxSpeed);
          // clear previous point selection
          if (selectedPointMarker) { map.removeLayer(selectedPointMarker); selectedPointMarker = null; }
          // attach click for this segment
          if (seg.points && seg.points.length) {
            const onLineClick = (e) => onPolylineClick(e, seg.points);
            seg.polyline.on('click', onLineClick);
            activeLineClickers.push({ pl: seg.polyline, onLineClick });
            // add tiny markers for this segment's points
            activePointMarkersGroup = L.layerGroup();
            seg.points.forEach((p, idx) => {
              if (typeof p.lat === 'number' && typeof p.lon === 'number') {
                const m = L.marker([p.lat, p.lon], { icon: tinySquareIcon });
                m.on('click', (ev) => {
                  L.DomEvent.stopPropagation(ev);
                  updateSelectedPoint(p, { prev: seg.points[idx-1], next: seg.points[idx+1] });
                });
                m.addTo(activePointMarkersGroup);
              }
            });
            activePointMarkersGroup.addTo(map);
          }
          setDetailsHint('Click on the red path to inspect a point.');
        });

        dayRows.push(dr);
        insertIndex += 1;
      });

      const btn = row.querySelector('.expander-btn');
      if (btn) {
        let expanded = false;
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          expanded = !expanded;
          btn.textContent = expanded ? '▾' : '▸';
          dayRows.forEach(r => r.classList.toggle('hidden', !expanded));
        });
      }
    }
  });
}

// call load() initially
load().then(() => setDetailsHint('Select a voyage, then click the red path to inspect points.')).catch(console.error);

// regenerate button logic, if you still have it
document.getElementById('regenBtn').addEventListener('click', async () => {
  await fetch('/plugins/voyage-webapp/generate', {
    method: 'GET',
    credentials: 'include'
  });
  await load();
});
</script>

<script>
// Simple details panel rendering
/**
 * setDetailsHint
 * Purpose: Show guidance text in the details panel.
 * Input: msg: string
 * Output: panel content updated
 */
function setDetailsHint(msg) {
  const panel = document.getElementById('pointDetails');
  panel.innerHTML = `<em>${msg}</em>`;
}

/**
 * degToCompassLocal
 * Purpose: Local copy used in details panel for wind direction.
 * Input: deg: number
 * Output: compass string
 */
function degToCompassLocal(deg) {
  const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  return dirs[Math.round(deg / 45) % 8];
}

/**
 * toDMS
 * Purpose: Convert decimal degrees to DMS string with hemisphere.
 * Input: value: number, isLat: boolean
 * Output: string like "48°07′30″N"
 */
function toDMS(value, isLat) {
  if (typeof value !== 'number' || Number.isNaN(value)) return '—';
  const abs = Math.abs(value);
  let deg = Math.floor(abs);
  let minFloat = (abs - deg) * 60;
  let min = Math.floor(minFloat);
  let sec = Math.round((minFloat - min) * 60);
  if (sec === 60) { sec = 0; min += 1; }
  if (min === 60) { min = 0; deg += 1; }
  const dir = isLat ? (value >= 0 ? 'N' : 'S') : (value >= 0 ? 'E' : 'W');
  const mm = String(min).padStart(2, '0');
  const ss = String(sec).padStart(2, '0');
  return `${deg}°${mm}′${ss}″${dir}`;
}

/**
 * formatPosition
 * Purpose: Human-readable combined DMS position string.
 * Input: lat, lon: numbers
 * Output: string or '—'
 */
function formatPosition(lat, lon) {
  if (typeof lat !== 'number' || typeof lon !== 'number') return '—';
  return `${toDMS(lat, true)} ${toDMS(lon, false)}`;
}

/**
 * renderPointDetails
 * Purpose: Render compact point summary and raw JSON in details panel.
 * Input: point: {lat,lon,entry?}
 * Output: updates panel HTML
 */
function renderPointDetails(point) {
  const panel = document.getElementById('pointDetails');
  const entry = point.entry || point; // fall back if only lon/lat exist

  // build a compact summary + raw JSON
  const when = entry.datetime ? new Date(entry.datetime).toLocaleString() : '—';
  const sog = entry?.speed?.sog;
  const stw = entry?.speed?.stw;
  const windSpd = entry?.wind?.speed;
  const windDir = entry?.wind?.direction;
  const windDirTxt = typeof windDir === 'number' ? `${windDir.toFixed(0)}° (${degToCompassLocal(windDir)})` : '—';

  const posStr = formatPosition(point.lat, point.lon);
  const summary = `
    <div><strong>Time:</strong> ${when}</div>
    <div><strong>Position:</strong> ${posStr}</div>
    <div><strong>SOG:</strong> ${typeof sog === 'number' ? sog.toFixed(2) + ' kn' : '—'}</div>
    <div><strong>STW:</strong> ${typeof stw === 'number' ? stw.toFixed(2) + ' kn' : '—'}</div>
    <div><strong>Wind:</strong> ${typeof windSpd === 'number' ? windSpd.toFixed(2) + ' kn' : '—'} @ ${windDirTxt}</div>
  `;

  const raw = `<pre style="white-space: pre-wrap;">${escapeHtml(JSON.stringify(entry, null, 2))}</pre>`;
  panel.innerHTML = `<h3 style="margin:0 0 6px 0;">Point Details</h3>${summary}<details><summary>Raw data</summary>${raw}</details>`;
}

/**
 * escapeHtml
 * Purpose: Basic HTML escaping for safe <pre> rendering.
 * Input: str: string
 * Output: escaped string
 */
function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

// Utilities for per-day segmentation and interaction
/**
 * detachActiveClickers
 * Purpose: Remove point-select click handlers from currently active polylines.
 * Input: none
 * Output: clears activeLineClickers list
 */
function detachActiveClickers() {
  if (Array.isArray(activeLineClickers)) {
    activeLineClickers.forEach(({ pl, onLineClick }) => {
      try { pl.off('click', onLineClick); } catch (_) {}
    });
  }
  activeLineClickers = [];
}

/**
 * onPolylineClick
 * Purpose: When clicking a red path, choose nearest point and select it.
 * Input: e: Leaflet mouse event, points: Array<{lat,lon,...}>
 * Output: updates selection and details
 */
function onPolylineClick(e, points) {
  if (!points || points.length === 0) return;
  const clickLL = e.latlng;
  let bestIdx = 0;
  let bestDist = Infinity;
  for (let idx = 0; idx < points.length; idx++) {
    const p = points[idx];
    if (typeof p.lat !== 'number' || typeof p.lon !== 'number') continue;
    const pll = L.latLng(p.lat, p.lon);
    const d = clickLL.distanceTo(pll);
    if (d < bestDist) { bestDist = d; bestIdx = idx; }
  }
  const sel = points[bestIdx];
  updateSelectedPoint(sel, { prev: points[bestIdx-1], next: points[bestIdx+1] });
}

// removed geodesic arrow helpers in favor of fixed-size SVG marker

/**
 * computeDaySegments
 * Purpose: Split a voyage's timestamped points into per-day segments and compute stats.
 * Input: v: voyage object { points: [{lat,lon,entry{datetime,...}}, ...] }
 * Output: Array of segments { dateKey, startTime, endTime, points, nm, maxSpeed, ... }
 */
function computeDaySegments(v) {
  const pts = Array.isArray(v.points) && v.points.length ? v.points : null;
  if (!pts) return [];
  const byDay = new Map();
  for (const p of pts) {
    const dtStr = p.entry?.datetime || p.datetime;
    if (!dtStr) continue;
    const d = new Date(dtStr);
    if (Number.isNaN(d)) continue;
    const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    if (!byDay.has(key)) byDay.set(key, []);
    byDay.get(key).push(p);
  }
  // sort keys
  const keys = Array.from(byDay.keys()).sort();
  const segments = [];
  for (const key of keys) {
    const points = byDay.get(key);
    // ensure points sorted by time
    points.sort((a,b) => new Date(a.entry?.datetime || a.datetime) - new Date(b.entry?.datetime || b.datetime));
    const startTime = points[0]?.entry?.datetime || points[0]?.datetime;
    const endTime = points[points.length-1]?.entry?.datetime || points[points.length-1]?.datetime;
    // metrics
    let nm = 0;
    let maxSpeed = 0;
    let maxSpeedCoord = null;
    let speedSum = 0, speedCount = 0;
    let maxWind = 0;
    let windSpeedSum = 0, windSpeedCount = 0;
    const windHeadings = [];
    for (let i = 0; i < points.length; i++) {
      if (i > 0) {
        const a = L.latLng(points[i-1].lat, points[i-1].lon);
        const b = L.latLng(points[i].lat, points[i].lon);
        nm += a.distanceTo(b) / 1852; // meters -> NM
      }
      const entry = points[i].entry || points[i];
      const s = entry?.speed?.sog ?? entry?.speed?.stw;
      if (typeof s === 'number') {
        if (s > maxSpeed) { maxSpeed = s; maxSpeedCoord = [points[i].lon, points[i].lat]; }
        speedSum += s; speedCount++;
      }
      const w = entry?.wind?.speed;
      if (typeof w === 'number') { if (w > maxWind) maxWind = w; windSpeedSum += w; windSpeedCount++; }
      const wd = entry?.wind?.direction; if (typeof wd === 'number') windHeadings.push(wd);
    }
    const avgSpeed = speedCount ? (speedSum / speedCount) : 0;
    const avgWindSpeed = windSpeedCount ? (windSpeedSum / windSpeedCount) : 0;
    const avgWindHeading = windHeadings.length ? circularMean(windHeadings) : null;
    segments.push({
      dateKey: key,
      startTime, endTime,
      nm: parseFloat(nm.toFixed(1)),
      maxSpeed, avgSpeed,
      maxWind, avgWindSpeed, avgWindHeading,
      points,
      maxSpeedCoord,
      polyline: null
    });
  }
  return segments;
}

/**
 * circularMean
 * Purpose: Mean direction for angles in degrees.
 * Input: degrees: number[] (0..360)
 * Output: number degrees (0..360)
 */
function circularMean(degrees) {
  // degrees: array of angles in degrees [0,360)
  let sumSin = 0, sumCos = 0;
  for (const d of degrees) {
    const rad = d * Math.PI / 180;
    sumSin += Math.sin(rad);
    sumCos += Math.cos(rad);
  }
  const avgRad = Math.atan2(sumSin / degrees.length, sumCos / degrees.length);
  let deg = avgRad * 180 / Math.PI;
  if (deg < 0) deg += 360;
  return deg;
}
</script>

</body>
</html>
