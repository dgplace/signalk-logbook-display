<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Logbook</title>
  <link rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  /* adopt Signal K theme variables with fallbacks */
  body, html {
    height: 100%;
    margin: 0;
    background-color: var(--background-page-color, #ffffff);
    color: var(--text-color, #000000);
    font-family: var(--font-family, sans-serif);
  }
  .container {
    width: 95%;
    margin: 0 auto;
    height: 100vh;            /* fill full viewport */
    display: grid;
    grid-template-rows: 25% 75%; /* 25% header/table, 75% map/panel */
    gap: 12px;
  }
  .top-section {
    display: flex;
    flex-direction: column;
    min-height: 0; /* allow inner scroll */
  }
  .header-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .table-wrapper {
    flex: 1 1 auto;
    min-height: 0;           /* important for flex children to allow overflow */
    overflow: auto;          /* scrollable table body */
    border: 1px solid var(--border-color, #334155);
    border-radius: 4px;
  }
  .map-row {
    display: flex;
    gap: 12px;
    align-items: stretch;
    min-height: 0; /* allow map to size correctly */
  }
  #map {
    flex: 1 1 87.5%;
    height: 100%;
    min-height: 200px;
  }
  /* style the regeneration button to match SK buttons */
  button#regenBtn {
    background-color: var(--button-primary-bg-color, #2563eb);
    color: var(--button-primary-text-color, #ffffff);
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
  }
  button#regenBtn:hover {
    background-color: var(--button-primary-bg-hover-color, #1e40af);
  }
  /* give the table Signal K‑style borders and zebra stripes */
  table {
    width: 100%;
    border-collapse: collapse;
    background: var(--background-table-color, #ffffff);
  }
  th, td {
    padding: 8px;
    border: 1px solid var(--border-color, #334155);
  }
  th {
    background-color: var(--table-header-bg-color, #e2e8f0);
    color: var(--table-header-text-color, #000000);
    position: sticky;  /* sticky header for scroll */
    top: 0;
    z-index: 1;
  }
  tbody tr:nth-child(odd) {
    background-color: var(--table-row-bg-alt-color, rgba(0,0,0,0.03));
  }
  tbody tr:hover {
    background-color: var(--table-row-hover-bg-color, blue);
    color: white;
  }
  .details-panel {
    flex: 0 0 12.5%;
    min-width: 180px;
    max-width: 420px;
    padding: 10px;
    border: 1px solid var(--border-color, #334155);
    border-radius: 4px;
    background-color: var(--background-input-color, #f8fafc);
    height: 100%;
    overflow: auto;
  }
  .expander-btn {
    border: none;
    background: transparent;
    cursor: pointer;
    font-size: 0.9em;
    margin-right: 6px;
  }
  .day-row {
    background-color: var(--table-row-bg-alt-color, rgba(0,0,0,0.03));
  }
  .day-row.hidden { display: none; }
  .idx-cell { white-space: nowrap; }

  /* Small square marker for selected point */
  .square-marker {
    width: 10px;
    height: 10px;
    background: var(--accent-color, #ef4444);
    border: 2px solid #ffffff;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
  }
</style>
</head>
<body>
<div class="container">
  <div class="top-section">
    <div class="header-bar">
      <h2 style="margin: 8px 0;">Logbook</h2>
      <button id="regenBtn">Regenerate voyages</button>
    </div>
    <div class="table-wrapper">
      <table id="voyTable">
        <thead><tr><th>#</th><th>Start</th><th>End</th><th>NM</th><th>Max Speed</th><th>Avg Speed</th><th>Max Wind</th><th>Avg Wind</th><th>Avg Wind Dir</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <div class="map-row">
    <div id="map"></div>
    <div id="pointDetails" class="details-panel" aria-live="polite"></div>
  </div>
</div>

<script>
function degToCompass(deg) {
  const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  return dirs[Math.round(deg / 45) % 8];
}
</script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
let map, polylines = [], maxMarker;
let activePolylines = [];        // currently highlighted red polylines
let activeLineClickers = [];     // stored click handlers for active polylines
let selectedPointMarker = null;  // marker for selected point
let squareIcon = L.divIcon({ className: 'square-marker', iconSize: [10,10] });

async function load() {
  // fetch the data
  const res  = await fetch('voyages.json');
  const data = await res.json();

  // if map already exists (after regeneration), remove it
  if (map) {
    map.off();       // remove all listeners
    map.remove();    // safely destroy the Leaflet map instance
  }
  polylines = [];
  maxMarker = null;

  map = L.map('map').setView([0, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
              { maxZoom: 19 }).addTo(map);

  const tbody = document.querySelector('#voyTable tbody');
  tbody.innerHTML = ''; // clear existing rows

  data.voyages.forEach((v, i) => {
    // create table row
    const avgWindDir = (v.avgWindHeading !== undefined && v.avgWindHeading !== null) ? degToCompass(v.avgWindHeading) : '';
    const row = tbody.insertRow();

    // Compute day segments if we have timestamped points
    const hasPoints = Array.isArray(v.points) && v.points.length && v.points[0].entry?.datetime;
    const segments = computeDaySegments(v);
    v._segments = segments; // store for later use

    const isMultiDay = segments.length > 1;
    const expander = isMultiDay ? `<button class="expander-btn" aria-label="Toggle days">▸</button>` : '';

    row.innerHTML =
      `<td class="idx-cell">${expander}${i+1}</td><td>${new Date(v.startTime).toLocaleString()}</td>
       <td>${new Date(v.endTime).toLocaleString()}</td>
       <td>${v.nm.toFixed(1)}</td>
       <td>${v.maxSpeed.toFixed(1)}</td>
       <td>${v.avgSpeed.toFixed(1)}</td>
       <td>${v.maxWind.toFixed(1)}</td>
       <td>${v.avgWindSpeed.toFixed(1)}</td>
       <td>${avgWindDir}</td>`;

    // draw the polyline(s) for this voyage and store them
    let voyageBounds = null;
    if (segments.length > 0) {
      segments.forEach(seg => {
        const latLngs = seg.points.map(p => [p.lat, p.lon]);
        const pl = L.polyline(latLngs, { color: 'blue', weight: 2 }).addTo(map);
        seg.polyline = pl;
        polylines.push(pl);
        const b = pl.getBounds();
        voyageBounds = voyageBounds ? voyageBounds.extend(b) : b;
      });
    } else {
      // fallback: draw entire voyage as a single line from coords
      const latLngs = v.coords.map(([lon, lat]) => [lat, lon]);
      const line = L.polyline(latLngs, { color: 'blue', weight: 2 }).addTo(map);
      polylines.push(line);
      v._fallbackPolyline = line;
      voyageBounds = line.getBounds();
    }
    if (i === 0 && voyageBounds) map.fitBounds(voyageBounds);

    // click handler to highlight this line
    row.addEventListener('click', () => {
      // reset all polylines to default style
      polylines.forEach(pl => pl.setStyle({ color: 'blue', weight: 2 }));
      // remove previous click handlers
      detachActiveClickers();

      // highlight selected voyage (all segments or fallback line)
      activePolylines = [];
      if (v._segments && v._segments.length > 0) {
        v._segments.forEach(seg => {
          seg.polyline.setStyle({ color: 'red', weight: 4 });
          activePolylines.push(seg.polyline);
        });
        // fit map bounds to selected voyage
        if (v._segments[0].polyline) {
          let b = v._segments[0].polyline.getBounds();
          for (let k = 1; k < v._segments.length; k++) {
            b = b.extend(v._segments[k].polyline.getBounds());
          }
          map.fitBounds(b);
        }
      } else if (v._fallbackPolyline) {
        v._fallbackPolyline.setStyle({ color: 'red', weight: 4 });
        activePolylines = [v._fallbackPolyline];
        map.fitBounds(v._fallbackPolyline.getBounds());
      }
      // remove existing marker
      if (maxMarker) {
        map.removeLayer(maxMarker);
        maxMarker = null;
      }
      if (v.maxSpeedCoord && v.maxSpeedCoord.length === 2) {
        const [lon, lat] = v.maxSpeedCoord;
        maxMarker = L.circleMarker([lat, lon], { color: 'orange', radius: 6 }).addTo(map);
        maxMarker.bindPopup(`Max SoG: ${v.maxSpeed.toFixed(1)} kn`).openPopup();
      }

      // clear previous point selection and handler
      if (selectedPointMarker) {
        map.removeLayer(selectedPointMarker);
        selectedPointMarker = null;
      }
      detachActiveClickers();

      // attach click handler to red path to select nearest point
      const voyagePoints = Array.isArray(v.points) && v.points.length ? v.points :
                           (Array.isArray(v.entries) && v.entries.length ? v.entries :
                             v.coords.map(([lon, lat]) => ({ lon, lat })));
      activePolylines.forEach(pl => {
        const onLineClick = (e) => onPolylineClick(e, voyagePoints);
        pl.on('click', onLineClick);
        activeLineClickers.push({ pl, onLineClick });
      });
      // initial details hint
      setDetailsHint('Click on the red path to inspect a point.');
    });

    // if multi-day, add collapsible day rows
    if (isMultiDay) {
      const dayRows = [];
      // use sectionRowIndex which is index within tbody, not global rowIndex
      let insertIndex = row.sectionRowIndex + 1;
      segments.forEach((seg, idx) => {
        const dr = tbody.insertRow(insertIndex);
        dr.classList.add('day-row', 'hidden');
        const avgWindDirDay = (seg.avgWindHeading !== undefined && seg.avgWindHeading !== null) ? degToCompass(seg.avgWindHeading) : '';
        dr.innerHTML = `
          <td class="idx-cell">↳ ${i+1}.${idx+1}</td>
          <td>${new Date(seg.startTime).toLocaleString()}</td>
          <td>${new Date(seg.endTime).toLocaleString()}</td>
          <td>${seg.nm.toFixed(1)}</td>
          <td>${seg.maxSpeed.toFixed(1)}</td>
          <td>${seg.avgSpeed.toFixed(1)}</td>
          <td>${seg.maxWind.toFixed(1)}</td>
          <td>${seg.avgWindSpeed.toFixed(1)}</td>
          <td>${avgWindDirDay}</td>
        `;

        // click handler for day row
        dr.addEventListener('click', () => {
          // reset to default
          polylines.forEach(pl => pl.setStyle({ color: 'blue', weight: 2 }));
          detachActiveClickers();
          activePolylines = [];
          // highlight only this day
          if (seg.polyline) {
            seg.polyline.setStyle({ color: 'red', weight: 4 });
            activePolylines = [seg.polyline];
            map.fitBounds(seg.polyline.getBounds());
          }
          // remove existing marker
          if (maxMarker) { map.removeLayer(maxMarker); maxMarker = null; }
          if (seg.maxSpeedCoord) {
            const [lon, lat] = seg.maxSpeedCoord;
            maxMarker = L.circleMarker([lat, lon], { color: 'orange', radius: 6 }).addTo(map);
            maxMarker.bindPopup(`Max SoG: ${seg.maxSpeed.toFixed(1)} kn`).openPopup();
          }
          // clear previous point selection
          if (selectedPointMarker) { map.removeLayer(selectedPointMarker); selectedPointMarker = null; }
          // attach click for this segment
          if (seg.points && seg.points.length) {
            const onLineClick = (e) => onPolylineClick(e, seg.points);
            seg.polyline.on('click', onLineClick);
            activeLineClickers.push({ pl: seg.polyline, onLineClick });
          }
          setDetailsHint('Click on the red path to inspect a point.');
        });

        dayRows.push(dr);
        insertIndex += 1;
      });

      const btn = row.querySelector('.expander-btn');
      if (btn) {
        let expanded = false;
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          expanded = !expanded;
          btn.textContent = expanded ? '▾' : '▸';
          dayRows.forEach(r => r.classList.toggle('hidden', !expanded));
        });
      }
    }
  });
}

// call load() initially
load().then(() => setDetailsHint('Select a voyage, then click the red path to inspect points.')).catch(console.error);

// regenerate button logic, if you still have it
document.getElementById('regenBtn').addEventListener('click', async () => {
  await fetch('/plugins/voyage-webapp/generate', {
    method: 'GET',
    credentials: 'include'
  });
  await load();
});
</script>

<script>
// Simple details panel rendering
function setDetailsHint(msg) {
  const panel = document.getElementById('pointDetails');
  panel.innerHTML = `<em>${msg}</em>`;
}

function degToCompassLocal(deg) {
  const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  return dirs[Math.round(deg / 45) % 8];
}

function toDMS(value, isLat) {
  if (typeof value !== 'number' || Number.isNaN(value)) return '—';
  const abs = Math.abs(value);
  let deg = Math.floor(abs);
  let minFloat = (abs - deg) * 60;
  let min = Math.floor(minFloat);
  let sec = Math.round((minFloat - min) * 60);
  if (sec === 60) { sec = 0; min += 1; }
  if (min === 60) { min = 0; deg += 1; }
  const dir = isLat ? (value >= 0 ? 'N' : 'S') : (value >= 0 ? 'E' : 'W');
  const mm = String(min).padStart(2, '0');
  const ss = String(sec).padStart(2, '0');
  return `${deg}°${mm}′${ss}″${dir}`;
}

function formatPosition(lat, lon) {
  if (typeof lat !== 'number' || typeof lon !== 'number') return '—';
  return `${toDMS(lat, true)} ${toDMS(lon, false)}`;
}

function renderPointDetails(point) {
  const panel = document.getElementById('pointDetails');
  const entry = point.entry || point; // fall back if only lon/lat exist

  // build a compact summary + raw JSON
  const when = entry.datetime ? new Date(entry.datetime).toLocaleString() : '—';
  const sog = entry?.speed?.sog;
  const stw = entry?.speed?.stw;
  const windSpd = entry?.wind?.speed;
  const windDir = entry?.wind?.direction;
  const windDirTxt = typeof windDir === 'number' ? `${windDir.toFixed(0)}° (${degToCompassLocal(windDir)})` : '—';

  const posStr = formatPosition(point.lat, point.lon);
  const summary = `
    <div><strong>Time:</strong> ${when}</div>
    <div><strong>Position:</strong> ${posStr}</div>
    <div><strong>SOG:</strong> ${typeof sog === 'number' ? sog.toFixed(2) + ' kn' : '—'}</div>
    <div><strong>STW:</strong> ${typeof stw === 'number' ? stw.toFixed(2) + ' kn' : '—'}</div>
    <div><strong>Wind:</strong> ${typeof windSpd === 'number' ? windSpd.toFixed(2) + ' kn' : '—'} @ ${windDirTxt}</div>
  `;

  const raw = `<pre style="white-space: pre-wrap;">${escapeHtml(JSON.stringify(entry, null, 2))}</pre>`;
  panel.innerHTML = `<h3 style="margin:0 0 6px 0;">Point Details</h3>${summary}<details><summary>Raw data</summary>${raw}</details>`;
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

// Utilities for per-day segmentation and interaction
function detachActiveClickers() {
  if (Array.isArray(activeLineClickers)) {
    activeLineClickers.forEach(({ pl, onLineClick }) => {
      try { pl.off('click', onLineClick); } catch (_) {}
    });
  }
  activeLineClickers = [];
}

function onPolylineClick(e, points) {
  if (!points || points.length === 0) return;
  const clickLL = e.latlng;
  let bestIdx = 0;
  let bestDist = Infinity;
  for (let idx = 0; idx < points.length; idx++) {
    const p = points[idx];
    if (typeof p.lat !== 'number' || typeof p.lon !== 'number') continue;
    const pll = L.latLng(p.lat, p.lon);
    const d = clickLL.distanceTo(pll);
    if (d < bestDist) { bestDist = d; bestIdx = idx; }
  }
  const sel = points[bestIdx];
  const lat = sel.lat, lon = sel.lon;
  if (!selectedPointMarker) {
    selectedPointMarker = L.marker([lat, lon], { icon: squareIcon, zIndexOffset: 1000 }).addTo(map);
  } else {
    selectedPointMarker.setLatLng([lat, lon]);
  }
  renderPointDetails(sel);
}

function computeDaySegments(v) {
  const pts = Array.isArray(v.points) && v.points.length ? v.points : null;
  if (!pts) return [];
  const byDay = new Map();
  for (const p of pts) {
    const dtStr = p.entry?.datetime || p.datetime;
    if (!dtStr) continue;
    const d = new Date(dtStr);
    if (Number.isNaN(d)) continue;
    const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    if (!byDay.has(key)) byDay.set(key, []);
    byDay.get(key).push(p);
  }
  // sort keys
  const keys = Array.from(byDay.keys()).sort();
  const segments = [];
  for (const key of keys) {
    const points = byDay.get(key);
    // ensure points sorted by time
    points.sort((a,b) => new Date(a.entry?.datetime || a.datetime) - new Date(b.entry?.datetime || b.datetime));
    const startTime = points[0]?.entry?.datetime || points[0]?.datetime;
    const endTime = points[points.length-1]?.entry?.datetime || points[points.length-1]?.datetime;
    // metrics
    let nm = 0;
    let maxSpeed = 0;
    let maxSpeedCoord = null;
    let speedSum = 0, speedCount = 0;
    let maxWind = 0;
    let windSpeedSum = 0, windSpeedCount = 0;
    const windHeadings = [];
    for (let i = 0; i < points.length; i++) {
      if (i > 0) {
        const a = L.latLng(points[i-1].lat, points[i-1].lon);
        const b = L.latLng(points[i].lat, points[i].lon);
        nm += a.distanceTo(b) / 1852; // meters -> NM
      }
      const entry = points[i].entry || points[i];
      const s = entry?.speed?.sog ?? entry?.speed?.stw;
      if (typeof s === 'number') {
        if (s > maxSpeed) { maxSpeed = s; maxSpeedCoord = [points[i].lon, points[i].lat]; }
        speedSum += s; speedCount++;
      }
      const w = entry?.wind?.speed;
      if (typeof w === 'number') { if (w > maxWind) maxWind = w; windSpeedSum += w; windSpeedCount++; }
      const wd = entry?.wind?.direction; if (typeof wd === 'number') windHeadings.push(wd);
    }
    const avgSpeed = speedCount ? (speedSum / speedCount) : 0;
    const avgWindSpeed = windSpeedCount ? (windSpeedSum / windSpeedCount) : 0;
    const avgWindHeading = windHeadings.length ? circularMean(windHeadings) : null;
    segments.push({
      dateKey: key,
      startTime, endTime,
      nm: parseFloat(nm.toFixed(1)),
      maxSpeed, avgSpeed,
      maxWind, avgWindSpeed, avgWindHeading,
      points,
      maxSpeedCoord,
      polyline: null
    });
  }
  return segments;
}

function circularMean(degrees) {
  // degrees: array of angles in degrees [0,360)
  let sumSin = 0, sumCos = 0;
  for (const d of degrees) {
    const rad = d * Math.PI / 180;
    sumSin += Math.sin(rad);
    sumCos += Math.cos(rad);
  }
  const avgRad = Math.atan2(sumSin / degrees.length, sumCos / degrees.length);
  let deg = avgRad * 180 / Math.PI;
  if (deg < 0) deg += 360;
  return deg;
}
</script>

</body>
</html>
